\chapter{Обзор существующих решений}
\label{sec:Chapter2} \index{Chapter2}

\section{Подход к размещению инвариантов цикла в компиляторной инфраструктуре LLVM}

Расположение инвариантов цикла в компиляторной инфраструктуре LLVM определяется двумя преобразованиями: вынос инвариантов из цикла и пропагация инвариантов в цикл.

\subsection{Вынос инвариантов из цикла}

Задача данной трансформации - вынести из цикла как можно больше инструкций для облегчения дальнейших оптимизаций циклов.

Дерево циклов функции обходится в порядке снизу - вверх, т.е. подциклы обрабатываются перед циклами.
Над каждым из циклов последовательно применяются две трансформации, описанные ниже.

\subsubsection{Вынос инструкций в блоки выхода}

Сначала все инструкции, не используемые в цикле выносятся в блоки выхода.
Это осуществляется следующим образом:
Базовые блоки обходятся в порядке, обратном к обходу в ширину дерева доминаторов внутри цикла.
Если блок - часть внутреннего цикла - он пропускается, так как он уже был обработан прежде.
Для каждой инструкции внутри базового блока:
\begin{itemize}
    \item Если у инструкции нет использований - она удаляется.
    \item Если все использования инструкции находятся вне цикла - она может быть перенесена в подмножество выходных блоков, которое доминирует блоки, содержащие использования результата исполнения инструкции.
        Такая трансформация может быть применена даже к инструкциям, операнды которых не являются инвариантами цикла, так как на момент использования будет наблюдаться только значение, полученое в последней итерации цикла.
        Для перемещения инструкции необходимо, чтобы она не имела никаких сторонних эффектов.
\end{itemize}

\subsubsection{Вынос инвариантов цикла в предзаголовок}

Остальные инструкции внутри цикла обрабатываются в соответствии со следующим алгоритмом:
\begin{itemize}
    \item Блоки цикла обходятся в глубину по дереву доминаторов.
        Блоки находящиеся во внутреннем цикле гнезда пропускаются, так как уже были обработаны прежде.
    \item Если не обладает сторонними эффектами и все ее операнды являются инвариантами цикла - она тоже является инвариантом цикла и выносится в предзаголовок.
        Порядок обхода упрощает определение, является ли некоторое значение инвариантом.
        Так как при описанном выше обходе, к моменту обработки блока, все доминирующие его блоки уже обработаны, инвариант может быть определен как значение, порождающая которое инструкция находится вне цикла.
\end{itemize}

\subsection{Пропагация инвариантов в цикл}

Эта трансформация применяется уже после осуществления всех цикловых оптимизаций.
Фактически, эта трансформация является обратной к выносу инвариантов из цикла в предзаголовок, с учетом того, что пропагируются только те инварианты, для которых можно вследствие этого уменьшить оценку частоты исполнения.
Это осуществляется следующим образом:
Дерево циклов обходится в том же порядке, что и при выносе инвариантов из цикла.
Такой порядок обеспечивает, что все инварианты внутренних циклов гнезда уже расположены оптимально, к моменту расположения инвариантов внешнего цикла.
Для каждого цикла строится множество базовых блоков принадлежащих циклу с меньшей частотой, чем у предзаголовка - множество \enquote{холодных} блоков.
Затем обходятся инструкции предзаголовка.
Любая инструкция предзаголовка, не обладающая сторонними эффектами является инвариантом цикла.
Для каждой инструкции, являющийся инвариантом, строится множество базовых блоков, содержащих использование этого значения.
Суммарная частота базовых блоков, входящих в это множество минимизируется следующим образом:
Для каждого базового блока из множества \enquote{холодных} блоков строится пересечение множества блоков, доминируемых \enquote{холодным} блоком, с множеством блоков содержащих использование инварианта.
Если суммарная частота блоков пересечения больше, чем частота \enquote{холодного} блока, эти блоки заменяются на \enquote{холодный}.

Если суммарная частота полученного множества меньше, чем частота предзаголовка, инвариант копируется во все базовые блоки множества и удаляется из предзаголовка.

Основным ограничением эффективности этой трансформации является точность анализа, предоставляющего частоту каждого блока.

\subsubsection{Построение анализа частот исполнения блоков}

Частота блоков вычисляется следующим образом:
\begin{itemize}
    \item{Обход всех сильно связных компонент графа потока управления}
        Использует LoopInfo анализ для предоставления информации о компонентах.
        Компоненты обходятся в таком порядке, что все вложенные компоненты обрападываются перед внешней.
        Нумерация компонент сохраняется и используется в дальнейшем.

    \item{Распределение весов в циклах}

        В случае если сильно связная компонента является гнездом циклов, подциклы обходятся перед основным циклом.
        Это позволяет представить внктренние циклы как вершины с уже рассчитаным весом.
        Масса распределяется внутри цикла без учета обратных дуг.
        Масса заголовок цикла $w_0 = 1$. Для каждой следующей вершины, вес рассчитывается как сумма произведений вероятности перехода в данную вершину из некоторой другой вершины на вес этой вершины.
        $$ w_j = \sum_{E(V_i, V_j)} w_i p_{ij} $$
        Порядок обхода обеспечивает, что вес вершины из которой направлена дуга уже рассчитан к моменту рассчета веса вершины в которую направлена дуга.
        Сумма $ w_j $ формируется из дуг внутри подграфа, направленных из уже обработанных блоков в еще не обработанные ($j > i$).
        Помимо этого, формируются сумма $ w_b $, отвечающая дугам направленым обратно в предзаголовок.
        Если существует дуга, направленная из уже обработанного блока в уже обработанный блок ($ j < i $), это свидетельствует о наличии несократимого потока управления -- сильно связной компоненты с многими точками входа.
        В этом случае алгоритм перезапускается, представляя каждую точку входа как заголовок цикла, при этом вся сильно связная компонента представляется набором таких циклов.

    \item{Рассчет числа итераций циклов}

        Число итераций цикла рассчитывается как:
        $$ s = \frac{1}{w_0 - w_b} $$

    \item{Распределение веса в функции}

        После того, как все циклы функции скомпанованы, вес внутри функции распределяется аналогично алгоритму распределения веса внутри циклов, учитывая что в полученном представлении функции нет обратных и выходящих дуг.

    \item{Рассчет частот исполнения блоков}

        Все циклы функции обходятся в обратном порядке, так что внешний цикл обрабатывается перед внутренним.
        Для блоков функции частота совпадает с весом.
        Для каждого блока внутри некоторого цикла, частота получается умножением числа итераций на частоту блока, который представлял скомпанованый цикл.

\end{itemize}

Для осуществления анализа частот исполнения блоков необходимо обладать информацией о вероятности перехода по каждой из дуг графа потока исполнения.
Эта информация предоставляется анализом вероятности переходов.

\subsubsection{Построение анализа вероятности переходов}

Цель анализа вероятности переходов -- построить соответствие между ребром графа потока исполнения и вероятностью перейти по этому ребру в ходе исполнения программы.

В ходе построения  анализа все базовые блоки внутри функции обхходятся в обратном порядке.
Если для базового блока существуют метаданные, предоставляющие информацию о числе переходов по каждой из дуг, собранную в ходе динамического профилиравания или полученную каким-либо образом из фронтенда, построение вероятностей перехода тривиально:
$$ p_{ij} = c_{j} / \sum_k{c_{ik}} $$
Где $c_k$ - число переходов по дуге из $i$ в $k$.

Если таких метаданных для блока нет, или если данный блок не был посещен ни разу в ходе исполнения программы для сборки профиля, последовательно применяются эвристики, пока некоторая из них не будет применима к данному блоку.

Первой применяется эвристика основанная на весах блоков
Предварительно, для всех специфичных базовых блоков функции, таких как блоки, в которых есть функция помеченная как не возвращающая управление или \enquote{холодная}, или блоки помеченные как недостижимые, или блоки, участвующие в обработке исключений (терминатор непосредственного доминатора - инструкция invoke), присваивается некоторый специфичный малый вес.
Всем дугам, выходящим из блока присваевается вес по умолчанию.
Для блоков внутри цикла, в отношении которых можно доказать, что условие становиться константой после некоторой итерации, вес дуги считается вдвое меньшим, чем для остальных блоков.
Для дуг, которые выходят из цикла, вес считается меньшим в оценку числа итераций раз.
Если существует выходящая дуга, вес которой отличен от веса по умолчанию по результату применения приведенных выше эвристик для определения весов, вероятность всех выходных дуг определяется как отношение веса дуги к суммарному весу.

Затем для базовых блоков терминатор которых является инструкцией сравнения применяются следующий ряд эвристик:
\begin{itemize}
    \item Сравнение указателей

        Применяется для случая сравнения на равенство двух указателей, или сравнения указателя с нулем.

    \item Сравнение c нулем

        Применяется для сравнения знаковой целой переменной с константой, при условии, что переменная не является результатом применения битовой маски.
        Если при этом переменная является результатом вызова одной из известных функций стандартной библиотеки такой, как strcmp, рассматриваются только сравнения на равенство или неравенство.
        Равенство числа нулю считается менее вероятным, чем неравенство.
        Считается менее вероятным, что число меньше или меньше либо равно нулю.

    \item Сравнение чисел с плавающей точкой

        Равенство двух чисел с плавающей точкой, каждое из которых не является нечислом (англ. NaN, not a number), считается менее вероятным, чем неравенство.
        То, что число с плавающей точкой является нечислом, считается маловероятным, так как часто служит для обработки исключительных ситуаций.

\end{itemize}

Значения вероятностей для этих эвристик представлены в таблице \ref{table:heuristics}.

\begin{table}[]
\input{include/llvm_static_bpi.tex}
\caption{Эвристики сравнений}
\label{table:heuristics}
\end{table}

\subsubsection{Динамическое профилирование}

Как видно из описания алгоритма построения анализа вероятности переходов, приведенного выше, единственным способом получить точные значения вероятности переходов, а следовательно и частоты исполнения базовых блоков является использование динамического профиля исполнения программы.

Динамический профиль состоит из значений счетчиков числа переходов по каждой дуге графа потока исполнения. Для получения данных значений код программы должен быть предварительно инструментирован и запущен. Точность профиля напрямую зависит от того, насколько совпадают входные данные программы при запуске, который создает профиль, и запуске на котором производятся измерения.

Для использования динамического профиля необходимо, чтобы внутреннее представление программы совпадало в момент инструментации кода и в момент использования профиля для аннотации дуг графа потока исполнения соответствующим этой дуге числом переходов.

\subsubsection{Инструментация кода}

Инструментация кода для сбора динамического профиля основана на использовании минимального остовного дерева, описанного в работе Дональда Э. Кнута, и Фрэнсиса Р. Стивенсона \cite{Knuth_Stevenson_1973}.
Этот алгоритм минимизирует число инструментируемых ребер графа, используя тот факт, что для каждой вершины, за исключением входной и выходной, сумма счетчиков, на ребрах входящих в вершину, равна сумме счетчиков на выходящих из вершины ребрах.
Таким образом, значения счетчиков на остовном дереве, могут быть неявно получены из значений счетчиков на ребрах не входящих в остовное дерево.
В работе доказывается, что инструментирование, построенное таким образом, инструментирует минимально возможное число ребер.

Ребра остовного дерева выбираются так, что их частота максимальна.
Для этого используется статический анализ частоты переходов.
Это позволяет минимизировать значения счетчиков, а следовательно и влияние на производительность программы при сборе профиля.

\section{Сравнение с подходом к размещению инвариантов цикла в компиляторной инфраструктуре GCC}

Подход к размещению инвариантов цикла в компиляторной инфраструктуре GCC во многом аналогичен.
Однако, можно выделить несколько принципиальных отличий:
\begin{itemize}
    \item Вынос инвариантов цикла не является приведением к канонической форме.
        Это позволяет не разделять алгоритм расположения инвариантов цикла на вынос и пропагацию, а обеспечивать эффективное расположение инвариантов в рамках единственной трансформации.
        Таким образом, алгоритм может работать быстрее, так как каждый инвариант обрабатывается строго один раз, в то время как в компиляторной инфраструктуре LLVM некоторые инварианты сначала выносятся в предзаголовок, а затем пропагируются обратно.
        В то же время, наличие инвариантов в теле цикла усложняет и замедляет работу многочисленных цикловых оптимизаций.
        Поэтому нельзя однозначно оценить, какой подход лучше.
    \item Статический анализ частот обеспечивает более точную оценку частоты исполнения базовых блоков.
        Это достигается за счет:
    \begin{itemize}
        \item Использование большего количества эвристик.
            Мотивация для использования именно этих эвристик и их значения описаны в работе \cite{Ball_Larus_1993}.
        \item Использование алгоритма объединения эвристик описанного в работах \cite{Youfeng_Wu_Larus} и \cite{Calder_Grunwald_Lindsay_Martin_Mozer_Zorn_1995}.
    \end{itemize}
\end{itemize}

Различия в точности анализа частот исполнения базовых блоков частично объясняют разрыв в эффективности компиляторов Clang и GCC на примере функции \texttt{S\_regmatch} из главы \ref{sec:Chapter1}.
Несмотря на это, как будет показано в дальнейшем, инварианты располагаются не оптимально в компиляторной инфраструктуре LLVM и при наличии динамического профиля, в случае чего различия в построении статического анализа не важны.

\newpage
