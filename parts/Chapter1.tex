\chapter{Постановка задачи}
\label{sec:Chapter1} \index{Chapter1}

\section{Расположение инварианта цикла}

Как уже было сказанно выше, скорость исполнения тела цикла является определяющим фактором скорости исполнения программы в целом.
Таким образом, становится ясна важность минимизации времени исполнения тела цикла.
Субоптимальное расположение инвариантов цикла может крайне негативно влиять на время исполнения программы, так как непосредственно увеличит число инструкций, которое необходимо исполнить.

Рассмотрим варианты расположения инварианта цикла в упрощенном представлении:
\begin{itemize}
    \item В теле цикла.

        Это расположение зачастую получается при построении внутреннего представления и редко является оптимальным, так как часто число итераций цикла больше единицы.

    \item В предзаголовке цикла.

        Такое расположение будет оптимальным для цикла, в теле которого используется инвариант, и число итераций которого больше единицы.

    \item В некоторых блоках выхода цикла.

        Этот вариант расположения доступен только в том случае, если инвариант не используется внутри цикла.
        Данный подход является оптимальным, при условии минимизации суммарной частоты выходных блоков в которые распологаются копии инварианта и дальнейшей пропагации инструкции без учета циклов.
\end{itemize}

Универсальным подходом является вынос инварианта из тела цикла в предзаголовок.
Однако этот метод будет эффективным только если среднее число исполнений тела цикла на каждый вход в цикл больше одного.
Иллюстративным примером случая, когда такое предположение не выполняется является функция \texttt{S\_regmatch} из бенчмарка \texttt{perlbench\_r} который является частью набора бенчмарка SPEC CPU\textsuperscript{\tiny\textregistered} 2017.

Данная функция имеет структуру, представленую на схеме \ref{fig:S_regmatch_concept}.
\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{images/S_regmatch_concept.pdf}
    \caption{Схема потока упровления в функции \texttt{S\_regmatch}}
    \label{fig:S_regmatch_concept}
\end{figure}

Функция состоит из цикла, выделенного на схеме черным.
Внутри цикла находится конструкция \texttt{switch} с большим количеством вариантов.
Большинство вариантов передают поток управления обратно к условию цикла, но некоторые передают его внутрь цикла, непосредственно на вход в конструкцию \texttt{switch}.
Таким образом, внутри цикла образуется еще один цикл, выделенный на схеме красным.

В следствие данной структуры графа потока управления, в ходе исполнения программы тело внешнего цикла посещается чаще, чем тело внутреннего цикла.
Таким образом, если некоторый инвариант внутреннего цикла, который не является инвариантом внешнего цикла, будет вынесен в предзаголовок внутреннего цикла, он окажется в теле внешнего цикла и число исполнений этой инструкции увеличится.

На данном примере Clang (компилятор языка С, использующий компиляторную инфраструктуру LLVM), показывает субоптимальный результат.
Среднее число инструкций на итерацию цикла больше, чем у компилятора GCC.

Это показывает на возможность улучшения алгоритма расположения инвариантов цикла в компиляторной инфраструктуре LLVM, что и является задачей данной работы.

\section{Формальная постановка задачи}

Рассмотрим задачу оптимального расположения инвариантов цикла формально.

Для каждого цикла, рассмвтривается множество блоков, доминируемых предзаголовком $p$

$$D = \{ \: d : p \: dom \: d \: \}$$.

Для каждого инварианта $i$ необходимо найти, такое множество $M$ что:
\begin{itemize}
    \item $M \subset D$
    \item $\forall \: u \in U(i) \: \exists \: m \in M : m \: dom \: u $, где $U(i)$ - множество блоков, содержащих использование инварианта $i$.
    \item $\sum_{m \in M}{f(m)} \to min $, где $f(m)$ - оценка частоты вероятности исполнения блока $m$.
\end{itemize}
\newpage
